using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Shared.Core.Data;
using Shared.Core.DTOs;
using Shared.Core.Entities;
using Shared.Core.Enums;
using Shared.Core.Repositories;
using Shared.Core.Services;
using Xunit;

namespace Shared.Core.Tests;

/// <summary>
/// Property-based tests for multi-business POS system functionality
/// Feature: multi-business-pos
/// </summary>
public class MultiBusinessPropertyTests : IDisposable
{
    private readonly ServiceProvider _serviceProvider;
    private readonly PosDbContext _context;

    public MultiBusinessPropertyTests()
    {
        var services = new ServiceCollection();
        
        // Add in-memory database
        services.AddDbContext<PosDbContext>(options =>
            options.UseInMemoryDatabase($"TestDb_{Guid.NewGuid()}"));
        
        // Add logging
        services.AddLogging(builder => builder.AddConsole());
        
        // Add repositories
        services.AddScoped<IProductRepository, ProductRepository>();
        services.AddScoped<ISaleRepository, SaleRepository>();
        services.AddScoped<IStockRepository, StockRepository>();
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IBusinessRepository, BusinessRepository>();
        services.AddScoped<IShopRepository, ShopRepository>();
        services.AddScoped<ICustomerRepository, CustomerRepository>();
        services.AddScoped<IDiscountRepository, DiscountRepository>();
        services.AddScoped<IConfigurationRepository, ConfigurationRepository>();
        services.AddScoped<ILicenseRepository, LicenseRepository>();
        
        // Add services
        services.AddScoped<IBusinessManagementService, BusinessManagementService>();
        services.AddScoped<IAuthenticationService, AuthenticationService>();
        services.AddScoped<IAuthorizationService, AuthorizationService>();
        services.AddScoped<IUserService, UserService>();
        services.AddScoped<ISessionService, SessionService>();
        services.AddScoped<IAuditService, AuditService>();
        services.AddScoped<IEncryptionService, EncryptionService>();
        services.AddScoped<IUserSessionRepository, UserSessionRepository>();
        services.AddScoped<IAuditLogRepository, AuditLogRepository>();
        services.AddScoped<ISaleService, SaleService>();
        services.AddScoped<IEnhancedSalesService, EnhancedSalesService>();
        services.AddScoped<IProductService, ProductService>();
        services.AddScoped<IInventoryService, InventoryService>();
        services.AddScoped<IWeightBasedPricingService, WeightBasedPricingService>();
        services.AddScoped<IMembershipService, MembershipService>();
        services.AddScoped<IDiscountService, DiscountService>();
        services.AddScoped<IConfigurationService, ConfigurationService>();
        services.AddScoped<ILicenseService, LicenseService>();
        services.AddScoped<ISaleItemRepository, SaleItemRepository>();
        services.AddSingleton<ICurrentUserService, CurrentUserService>();
        
        // Add sync services for testing
        services.AddScoped<ISyncEngine, SyncEngine>();
        services.AddScoped<IConnectivityService, ConnectivityService>();
        services.AddScoped<ISyncApiClient, SyncApiClient>();
        services.AddScoped<IMultiTenantSyncService, MultiTenantSyncService>();
        services.AddHttpClient<ISyncApiClient, SyncApiClient>();
        
        // Add sync configuration for testing
        services.AddSingleton(provider => new SyncConfiguration
        {
            DeviceId = Guid.NewGuid(),
            ServerBaseUrl = "https://test.example.com",
            SyncInterval = TimeSpan.FromMinutes(5),
            MaxRetryAttempts = 3,
            InitialRetryDelay = TimeSpan.FromSeconds(1),
            RetryBackoffMultiplier = 2.0
        });
        
        _serviceProvider = services.BuildServiceProvider();
        _context = _serviceProvider.GetRequiredService<PosDbContext>();
        
        // Ensure database is created
        _context.Database.EnsureCreated();
    }

    /// <summary>
    /// Property 1: Multi-Tenant Data Isolation
    /// For any two different businesses, data operations on one business should never affect or access data belonging to the other business.
    /// Validates: Requirements 6.4, 6.5
    /// Feature: multi-business-pos, Property 1: Multi-Tenant Data Isolation
    /// </summary>
    [Fact]
    public void MultiTenantDataIsolation_BusinessDataShouldBeIsolated()
    {
        // Test with multiple random business scenarios
        for (int iteration = 0; iteration < 10; iteration++)
        {
            // Generate two different businesses
            var businessData1 = GenerateBusinessData();
            var businessData2 = GenerateBusinessData();
            
            // Ensure different business IDs
            while (businessData1.BusinessId == businessData2.BusinessId)
            {
                businessData2 = GenerateBusinessData();
            }

            try
            {
                // Setup: Create two separate businesses with their data
                SetupBusinessData(businessData1);
                SetupBusinessData(businessData2);

                // Test: Verify that queries for business1 data don't return business2 data
                var business1Products = _context.Products
                    .Include(p => p.Shop)
                    .Where(p => p.Shop.BusinessId == businessData1.BusinessId)
                    .ToList();
                
                var business1Sales = _context.Sales
                    .Include(s => s.Shop)
                    .Where(s => s.Shop.BusinessId == businessData1.BusinessId)
                    .ToList();
                
                var business1Stock = _context.Stock
                    .Include(s => s.Shop)
                    .Where(s => s.Shop.BusinessId == businessData1.BusinessId)
                    .ToList();

                // Verify isolation: Business1 queries should not contain Business2 data
                var hasNoBusinessTwoProducts = business1Products.All(p => 
                    p.Shop.BusinessId == businessData1.BusinessId);
                
                var hasNoBusinessTwoSales = business1Sales.All(s => 
                    s.Shop.BusinessId == businessData1.BusinessId);
                
                var hasNoBusinessTwoStock = business1Stock.All(s => 
                    s.Shop.BusinessId == businessData1.BusinessId);

                // Test reverse direction as well
                var business2Products = _context.Products
                    .Include(p => p.Shop)
                    .Where(p => p.Shop.BusinessId == businessData2.BusinessId)
                    .ToList();
                
                var hasNoBusinessOneProducts = business2Products.All(p => 
                    p.Shop.BusinessId == businessData2.BusinessId);

                // Assert isolation
                Assert.True(hasNoBusinessTwoProducts, $"Business1 products contain Business2 data in iteration {iteration}");
                Assert.True(hasNoBusinessTwoSales, $"Business1 sales contain Business2 data in iteration {iteration}");
                Assert.True(hasNoBusinessTwoStock, $"Business1 stock contains Business2 data in iteration {iteration}");
                Assert.True(hasNoBusinessOneProducts, $"Business2 products contain Business1 data in iteration {iteration}");
                
                // Verify that each business has its own data
                Assert.True(business1Products.Count > 0, $"Business1 should have products in iteration {iteration}");
                Assert.True(business2Products.Count > 0, $"Business2 should have products in iteration {iteration}");
            }
            finally
            {
                // Cleanup: Remove test data
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 3: Business Type Validation Consistency
    /// For any product sale attempt, the validation rules applied should be consistent with the business type configuration of the shop.
    /// Validates: Requirements 1.5, 5.6
    /// Feature: multi-business-pos, Property 3: Business Type Validation Consistency
    /// </summary>
    [Fact]
    public async Task BusinessTypeValidation_ValidationRulesShouldBeConsistentWithBusinessType()
    {
        var businessManagementService = _serviceProvider.GetRequiredService<IBusinessManagementService>();
        
        // Test with multiple random business type scenarios
        for (int iteration = 0; iteration < 10; iteration++)
        {
            try
            {
                // Generate random business type and attributes
                var businessTypes = Enum.GetValues<BusinessType>();
                var random = new Random();
                var businessType = businessTypes[random.Next(businessTypes.Length)];
                var attributes = GenerateRandomBusinessTypeAttributes(businessType, random);

                // Test: Validate product attributes against business type
                var validationResult = await businessManagementService.ValidateProductAttributesAsync(businessType, attributes);

                // Verify consistency: Validation should be consistent with business type requirements
                switch (businessType)
                {
                    case BusinessType.Pharmacy:
                        // For pharmacy, expiry date should be required and validated
                        if (attributes.ExpiryDate.HasValue && attributes.ExpiryDate.Value <= DateTime.UtcNow)
                        {
                            Assert.False(validationResult.IsValid, 
                                $"Pharmacy products with past expiry dates should be invalid in iteration {iteration}");
                            Assert.Contains(validationResult.Errors, e => e.Contains("expiry", StringComparison.OrdinalIgnoreCase));
                        }
                        
                        // Required attributes should cause validation failure if missing
                        if (string.IsNullOrEmpty(attributes.Manufacturer))
                        {
                            Assert.False(validationResult.IsValid, 
                                $"Pharmacy products without manufacturer should be invalid in iteration {iteration}");
                        }
                        break;

                    case BusinessType.Grocery:
                        // For grocery, weight should be positive if specified
                        if (attributes.Weight.HasValue && attributes.Weight.Value <= 0)
                        {
                            Assert.False(validationResult.IsValid, 
                                $"Grocery products with non-positive weight should be invalid in iteration {iteration}");
                            Assert.Contains(validationResult.Errors, e => e.Contains("weight", StringComparison.OrdinalIgnoreCase));
                        }
                        
                        // Unit should be required for grocery
                        if (string.IsNullOrEmpty(attributes.Unit))
                        {
                            Assert.False(validationResult.IsValid, 
                                $"Grocery products without unit should be invalid in iteration {iteration}");
                        }
                        break;

                    case BusinessType.GeneralRetail:
                    case BusinessType.Custom:
                    case BusinessType.SuperShop:
                        // These types have more flexible validation
                        if (attributes.Weight.HasValue && attributes.Weight.Value <= 0)
                        {
                            Assert.False(validationResult.IsValid, 
                                $"Products with non-positive weight should be invalid in iteration {iteration}");
                        }
                        break;
                }

                // Verify that validation is deterministic - same input should give same result
                var secondValidationResult = await businessManagementService.ValidateProductAttributesAsync(businessType, attributes);
                Assert.Equal(validationResult.IsValid, secondValidationResult.IsValid);
                Assert.Equal(validationResult.Errors.Count, secondValidationResult.Errors.Count);
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 2: Role-Based Access Enforcement
    /// For any user and permission, the system should only allow access to resources that match the user's role and assigned permissions.
    /// Validates: Requirements 4.2, 4.3, 4.4, 4.5, 4.6
    /// Feature: multi-business-pos, Property 2: Role-Based Access Enforcement
    /// </summary>
    [Fact]
    public async Task RoleBasedAccessEnforcement_UsersShouldOnlyAccessResourcesMatchingTheirRoleAndPermissions()
    {
        var authenticationService = _serviceProvider.GetRequiredService<IAuthenticationService>();
        var authorizationService = _serviceProvider.GetRequiredService<IAuthorizationService>();
        var userService = _serviceProvider.GetRequiredService<IUserService>();
        
        // Test with multiple random user/permission scenarios
        for (int iteration = 0; iteration < 20; iteration++)
        {
            try
            {
                // Generate random user with random role and business/shop assignment
                var userData = GenerateRandomUserData();
                var user = await CreateTestUser(userData);

                // Get user permissions
                var userPermissions = await authenticationService.GetUserPermissionsAsync(user.Id);

                // Test various permission scenarios
                var testPermissions = GenerateTestPermissions();
                
                foreach (var permission in testPermissions)
                {
                    // Test permission validation
                    var hasPermission = await authenticationService.ValidatePermissionAsync(
                        user.Id, permission.Action, permission.ShopId);
                    
                    // Verify role-based access enforcement
                    var expectedAccess = ShouldUserHaveAccess(userData.Role, permission, userData.BusinessId, userData.ShopId);
                    
                    if (expectedAccess != hasPermission)
                    {
                        Assert.True(false, 
                            $"User with role {userData.Role} should {(expectedAccess ? "have" : "not have")} " +
                            $"access to {permission.Action} for shop {permission.ShopId} in iteration {iteration}");
                    }

                    // Test authorization service consistency
                    var authServiceResult = authorizationService.HasPermission(user.Role, 
                        Enum.Parse<AuditAction>(permission.Action));
                    
                    // For basic role permissions (without shop context), results should be consistent
                    if (permission.ShopId == null || userData.CanAccessShop(permission.ShopId.Value))
                    {
                        if (authServiceResult != hasPermission)
                        {
                            Assert.True(false,
                                $"Authorization service and authentication service should be consistent " +
                                $"for role {userData.Role} and action {permission.Action} in iteration {iteration}");
                        }
                    }
                }

                // Test shop-level access control
                if (userData.ShopId.HasValue)
                {
                    // User should be able to access their assigned shop
                    var canAccessOwnShop = userPermissions.CanAccessShop(userData.ShopId.Value);
                    Assert.True(canAccessOwnShop, 
                        $"User should be able to access their assigned shop in iteration {iteration}");

                    // User should not be able to access other shops (unless BusinessOwner)
                    var otherShopId = Guid.NewGuid();
                    var canAccessOtherShop = userPermissions.CanAccessShop(otherShopId);
                    
                    if (userData.Role == UserRole.BusinessOwner)
                    {
                        Assert.True(canAccessOtherShop, 
                            $"Business owner should be able to access any shop in iteration {iteration}");
                    }
                    else
                    {
                        Assert.False(canAccessOtherShop, 
                            $"Non-business-owner should not be able to access other shops in iteration {iteration}");
                    }
                }

                // Test business-level isolation
                var otherBusinessUser = GenerateRandomUserData();
                otherBusinessUser.BusinessId = Guid.NewGuid(); // Different business
                var otherUser = await CreateTestUser(otherBusinessUser);

                // Ensure we have a shop to test cross-business access
                var testShopId = userData.ShopId ?? Guid.NewGuid();
                if (!userData.ShopId.HasValue)
                {
                    // Create a shop for the original user's business to test cross-business access
                    var testShop = new Shop
                    {
                        Id = testShopId,
                        BusinessId = userData.BusinessId,
                        Name = $"Test Shop {testShopId:N}",
                        DeviceId = Guid.NewGuid()
                    };
                    _context.Shops.Add(testShop);
                    await _context.SaveChangesAsync();
                }

                // Users from different businesses should not be able to access each other's resources
                var crossBusinessAccess = await authenticationService.ValidatePermissionAsync(
                    otherUser.Id, "CreateSale", testShopId);
                
                Assert.False(crossBusinessAccess, 
                    $"Users from different businesses should not have cross-business access in iteration {iteration}");
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 5: Offline Authentication Expiration
    /// For any cached authentication token, access should be denied when the token has exceeded its configured expiration time.
    /// Validates: Requirements 3.4, 3.5
    /// Feature: multi-business-pos, Property 5: Offline Authentication Expiration
    /// </summary>
    [Fact]
    public async Task OfflineAuthenticationExpiration_AccessShouldBeDeniedWhenTokenExpired()
    {
        var authenticationService = _serviceProvider.GetRequiredService<IAuthenticationService>();
        var userService = _serviceProvider.GetRequiredService<IUserService>();
        
        // Test with multiple random expiration scenarios
        for (int iteration = 0; iteration < 15; iteration++)
        {
            try
            {
                // Generate random user and expiration time
                var userData = GenerateRandomUserData();
                var user = await CreateTestUser(userData);
                
                var random = new Random();
                var expirationMinutes = random.Next(-60, 120); // -60 to 120 minutes (past to future)
                var expiration = TimeSpan.FromMinutes(expirationMinutes);
                
                // Create a cached token
                var token = GenerateRandomToken();
                await authenticationService.CacheCredentialsAsync(user.Id, token, expiration);

                // Test offline authentication
                var authResult = await authenticationService.AuthenticateOfflineAsync(userData.Username, token);

                // Verify expiration behavior
                var shouldBeValid = expirationMinutes > 0; // Only future expiration times should be valid
                
                if (shouldBeValid != authResult.IsSuccess)
                {
                    Assert.True(false,
                        $"Token with expiration {expirationMinutes} minutes should {(shouldBeValid ? "be valid" : "be expired")} " +
                        $"but authentication result was {authResult.IsSuccess} in iteration {iteration}");
                }

                // For expired tokens, verify error message indicates expiration
                if (!shouldBeValid && !authResult.IsSuccess)
                {
                    var errorMessage = authResult.ErrorMessage?.ToLower() ?? "";
                    Assert.True(errorMessage.Contains("expired"), 
                        $"Error message should indicate expiration in iteration {iteration}. Got: {authResult.ErrorMessage}");
                }

                // For valid tokens, verify user is returned
                if (shouldBeValid && authResult.IsSuccess)
                {
                    Assert.NotNull(authResult.User);
                    Assert.Equal(user.Id, authResult.User.Id);
                    Assert.True(authResult.IsOfflineMode, 
                        $"Offline authentication should set IsOfflineMode to true in iteration {iteration}");
                }

                // Test token validation directly
                var isTokenValid = await authenticationService.ValidateCachedTokenAsync(user.Id, token);
                if (shouldBeValid != isTokenValid)
                {
                    Assert.True(false,
                        $"Direct token validation should match authentication result in iteration {iteration}");
                }

                // Test with wrong token - should always fail
                var wrongToken = GenerateRandomToken();
                var wrongTokenResult = await authenticationService.AuthenticateOfflineAsync(userData.Username, wrongToken);
                Assert.False(wrongTokenResult.IsSuccess, 
                    $"Authentication with wrong token should always fail in iteration {iteration}");

                // Test with non-existent user - should always fail
                var nonExistentResult = await authenticationService.AuthenticateOfflineAsync("nonexistent", token);
                Assert.False(nonExistentResult.IsSuccess, 
                    $"Authentication with non-existent user should always fail in iteration {iteration}");
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 4: Shop-Level Configuration Isolation
    /// For any shop configuration change, it should only affect operations within that specific shop and not impact other shops.
    /// Validates: Requirements 2.4, 2.6
    /// Feature: multi-business-pos, Property 4: Shop-Level Configuration Isolation
    /// </summary>
    [Fact]
    public async Task ShopConfigurationIsolation_ConfigurationChangesShouldOnlyAffectTargetShop()
    {
        var businessManagementService = _serviceProvider.GetRequiredService<IBusinessManagementService>();
        
        // Test with multiple random shop configuration scenarios
        for (int iteration = 0; iteration < 10; iteration++)
        {
            try
            {
                // Setup: Create a business with multiple shops
                var businessData = GenerateBusinessWithMultipleShops();
                SetupBusinessWithShops(businessData);

                var targetShopId = businessData.ShopIds[0];
                var otherShopIds = businessData.ShopIds.Skip(1).ToList();

                // Generate random configuration for target shop
                var random = new Random();
                var newConfiguration = GenerateRandomShopConfiguration(random);

                // Get original configurations of other shops
                var originalConfigurations = new Dictionary<Guid, ShopConfiguration>();
                foreach (var shopId in otherShopIds)
                {
                    originalConfigurations[shopId] = await businessManagementService.GetShopConfigurationAsync(shopId);
                }

                // Test: Update configuration of target shop
                var updateResult = await businessManagementService.UpdateShopConfigurationAsync(targetShopId, newConfiguration);
                Assert.True(updateResult, $"Configuration update should succeed in iteration {iteration}");

                // Verify isolation: Other shops' configurations should remain unchanged
                foreach (var shopId in otherShopIds)
                {
                    var currentConfig = await businessManagementService.GetShopConfigurationAsync(shopId);
                    var originalConfig = originalConfigurations[shopId];

                    // Compare key configuration values
                    Assert.Equal(originalConfig.Currency, currentConfig.Currency);
                    Assert.Equal(originalConfig.TaxRate, currentConfig.TaxRate);
                    Assert.Equal(originalConfig.PricingRules.MaxDiscountPercentage, currentConfig.PricingRules.MaxDiscountPercentage);
                    Assert.Equal(originalConfig.InventorySettings.LowStockThreshold, currentConfig.InventorySettings.LowStockThreshold);
                }

                // Verify that target shop has the new configuration
                var targetConfig = await businessManagementService.GetShopConfigurationAsync(targetShopId);
                Assert.Equal(newConfiguration.Currency, targetConfig.Currency);
                Assert.Equal(newConfiguration.TaxRate, targetConfig.TaxRate);
                Assert.Equal(newConfiguration.PricingRules.MaxDiscountPercentage, targetConfig.PricingRules.MaxDiscountPercentage);
                Assert.Equal(newConfiguration.InventorySettings.LowStockThreshold, targetConfig.InventorySettings.LowStockThreshold);
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 6: Sales Calculation Accuracy
    /// For any sale with multiple items, discounts, and taxes, the final total should equal the sum of line totals minus discounts plus taxes.
    /// Validates: Requirements 5.2
    /// Feature: multi-business-pos, Property 6: Sales Calculation Accuracy
    /// </summary>
    [Fact]
    public async Task SalesCalculationAccuracy_FinalTotalShouldEqualSumOfLineItemsMinusDiscountsPlusTaxes()
    {
        var enhancedSalesService = _serviceProvider.GetRequiredService<IEnhancedSalesService>();
        var productService = _serviceProvider.GetRequiredService<IProductService>();
        var saleItemRepository = _serviceProvider.GetRequiredService<ISaleItemRepository>();
        
        // Test with multiple random sale scenarios
        for (int iteration = 0; iteration < 20; iteration++)
        {
            try
            {
                // Setup: Create a business with shop and products
                var saleTestData = GenerateRandomSaleTestData();
                await SetupSaleTestDataAsync(saleTestData);

                // Create sale with validation
                var sale = await enhancedSalesService.CreateSaleWithValidationAsync(
                    saleTestData.ShopId, saleTestData.UserId, $"INV{iteration:D4}");

                // Add random items to the sale
                var expectedLineTotal = 0m;
                foreach (var itemData in saleTestData.SaleItems)
                {
                    if (itemData.IsWeightBased)
                    {
                        await enhancedSalesService.AddWeightBasedItemToSaleAsync(
                            sale.Id, itemData.ProductId, itemData.Weight!.Value, itemData.BatchNumber);
                        
                        // Calculate expected line total for weight-based items
                        var product = await productService.GetProductByIdAsync(itemData.ProductId);
                        expectedLineTotal += itemData.Weight!.Value * product!.RatePerKilogram!.Value;
                    }
                    else
                    {
                        await enhancedSalesService.AddItemToSaleAsync(
                            sale.Id, itemData.ProductId, itemData.Quantity, itemData.UnitPrice, itemData.BatchNumber);
                        
                        expectedLineTotal += itemData.Quantity * itemData.UnitPrice;
                    }
                }

                // Calculate with business rules
                var calculationResult = await enhancedSalesService.CalculateWithBusinessRulesAsync(sale);

                // Verify calculation accuracy
                var actualLineTotal = calculationResult.BaseTotal;
                var finalTotal = calculationResult.FinalTotal;
                var discountAmount = calculationResult.DiscountAmount + calculationResult.MembershipDiscountAmount;
                var taxAmount = calculationResult.TaxAmount;

                // Property: Final total should equal base total minus discounts plus taxes
                var expectedFinalTotal = actualLineTotal - discountAmount + taxAmount;
                
                // Allow for small rounding differences (within 0.01)
                var tolerance = 0.01m;
                var totalDifference = Math.Abs(finalTotal - expectedFinalTotal);
                
                Assert.True(totalDifference <= tolerance,
                    $"Final total calculation incorrect in iteration {iteration}. " +
                    $"Expected: {expectedFinalTotal:C}, Actual: {finalTotal:C}, " +
                    $"Base: {actualLineTotal:C}, Discounts: {discountAmount:C}, Tax: {taxAmount:C}, " +
                    $"Difference: {totalDifference:C}");

                // Verify base total matches sum of line items
                var saleItems = await saleItemRepository.FindAsync(si => si.SaleId == sale.Id);
                var actualSumOfLineItems = saleItems.Sum(si => si.TotalPrice);
                
                var baseTotalDifference = Math.Abs(actualLineTotal - actualSumOfLineItems);
                Assert.True(baseTotalDifference <= tolerance,
                    $"Base total should match sum of line items in iteration {iteration}. " +
                    $"Base Total: {actualLineTotal:C}, Sum of Line Items: {actualSumOfLineItems:C}, " +
                    $"Difference: {baseTotalDifference:C}");

                // Verify all amounts are non-negative
                Assert.True(actualLineTotal >= 0, $"Base total should be non-negative in iteration {iteration}");
                Assert.True(discountAmount >= 0, $"Discount amount should be non-negative in iteration {iteration}");
                Assert.True(taxAmount >= 0, $"Tax amount should be non-negative in iteration {iteration}");
                Assert.True(finalTotal >= 0, $"Final total should be non-negative in iteration {iteration}");

                // Verify discounts don't exceed base total
                Assert.True(discountAmount <= actualLineTotal,
                    $"Discount amount should not exceed base total in iteration {iteration}. " +
                    $"Discount: {discountAmount:C}, Base: {actualLineTotal:C}");

                // Verify calculation is deterministic - same input should give same result
                var secondCalculationResult = await enhancedSalesService.CalculateWithBusinessRulesAsync(sale);
                Assert.Equal(calculationResult.FinalTotal, secondCalculationResult.FinalTotal);
                Assert.Equal(calculationResult.BaseTotal, secondCalculationResult.BaseTotal);
                Assert.Equal(calculationResult.DiscountAmount, secondCalculationResult.DiscountAmount);
                Assert.Equal(calculationResult.TaxAmount, secondCalculationResult.TaxAmount);
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Property 7: Inventory Synchronization Consistency
    /// For any inventory update, the final stock level should be consistent across all synchronized devices after conflict resolution.
    /// Validates: Requirements 7.3, 7.4
    /// Feature: multi-business-pos, Property 7: Inventory Synchronization Consistency
    /// </summary>
    [Fact]
    public async Task InventorySynchronizationConsistency_FinalStockLevelShouldBeConsistentAfterConflictResolution()
    {
        var multiTenantSyncService = _serviceProvider.GetRequiredService<IMultiTenantSyncService>();
        var stockRepository = _serviceProvider.GetRequiredService<IStockRepository>();
        var productRepository = _serviceProvider.GetRequiredService<IProductRepository>();
        
        // Test with multiple random synchronization scenarios
        for (int iteration = 0; iteration < 15; iteration++)
        {
            try
            {
                // Setup: Create a business with multiple shops and products
                var syncTestData = GenerateRandomSyncTestData();
                await SetupSyncTestDataAsync(syncTestData);

                // Simulate concurrent inventory updates from different devices
                var conflictScenarios = GenerateInventoryConflictScenarios(syncTestData);
                
                foreach (var scenario in conflictScenarios)
                {
                    // Apply local changes to simulate offline updates
                    await ApplyLocalInventoryChangesAsync(scenario.LocalChanges);
                    
                    // Simulate server changes
                    await ApplyServerInventoryChangesAsync(scenario.ServerChanges);
                    
                    // Create data conflicts for resolution
                    var conflicts = await CreateInventoryConflictsAsync(scenario);
                    
                    // Test: Resolve conflicts using multi-tenant sync service
                    var resolutionResult = await multiTenantSyncService.ResolveDataConflictsAsync(conflicts.ToArray());
                    
                    // Verify conflict resolution succeeded
                    Assert.True(resolutionResult.Success, 
                        $"Conflict resolution should succeed in iteration {iteration}, scenario {scenario.ScenarioId}");
                    
                    // Verify consistency: Final stock levels should be deterministic
                    foreach (var productId in scenario.AffectedProducts)
                    {
                        var finalStock = await stockRepository.GetStockByProductIdAsync(productId);
                        Assert.NotNull(finalStock);
                        
                        // Stock level should be non-negative after conflict resolution
                        Assert.True(finalStock.Quantity >= 0, 
                            $"Final stock quantity should be non-negative for product {productId} " +
                            $"in iteration {iteration}, scenario {scenario.ScenarioId}. Got: {finalStock.Quantity}");
                        
                        // Verify that the same conflict resolution produces the same result
                        var secondResolutionResult = await multiTenantSyncService.ResolveDataConflictsAsync(conflicts.ToArray());
                        var secondFinalStock = await stockRepository.GetStockByProductIdAsync(productId);
                        
                        Assert.Equal(finalStock.Quantity, secondFinalStock.Quantity);
                        Assert.Equal(finalStock.LastUpdatedAt, secondFinalStock.LastUpdatedAt);
                    }
                    
                    // Verify tenant isolation: Changes should only affect the correct business
                    var businessProducts = await productRepository.GetProductsByShopIdAsync(syncTestData.ShopId);
                    var businessStock = new List<Stock>();
                    
                    foreach (var product in businessProducts)
                    {
                        var stock = await stockRepository.GetStockByProductIdAsync(product.Id);
                        if (stock != null)
                        {
                            businessStock.Add(stock);
                        }
                    }
                    
                    // All stock records should belong to the correct business
                    var isolationValid = await multiTenantSyncService.ValidateTenantIsolationAsync(
                        syncTestData.BusinessId, businessStock);
                    
                    Assert.True(isolationValid, 
                        $"Tenant isolation should be maintained after sync in iteration {iteration}, scenario {scenario.ScenarioId}");
                    
                    // Verify synchronization consistency across multiple sync operations
                    var firstSyncResult = await multiTenantSyncService.SyncShopDataAsync(syncTestData.ShopId);
                    var secondSyncResult = await multiTenantSyncService.SyncShopDataAsync(syncTestData.ShopId);
                    
                    // Multiple syncs of the same data should be idempotent
                    Assert.Equal(firstSyncResult.Success, secondSyncResult.Success);
                    
                    if (firstSyncResult.Success && secondSyncResult.Success)
                    {
                        // Second sync should have no changes if first sync was successful
                        Assert.True(secondSyncResult.ItemsSynced <= firstSyncResult.ItemsSynced,
                            $"Second sync should not sync more items than first sync in iteration {iteration}");
                    }
                }
                
                // Test business-level synchronization consistency
                var businessSyncResult = await multiTenantSyncService.SyncBusinessDataAsync(syncTestData.BusinessId);
                
                if (businessSyncResult.Success)
                {
                    // Verify that all shops in the business have consistent data
                    var shopSyncStatuses = await multiTenantSyncService.GetBusinessSyncStatusAsync(syncTestData.BusinessId);
                    
                    foreach (var shopStatus in shopSyncStatuses)
                    {
                        Assert.True(shopStatus.HealthStatus != SyncHealthStatus.Error,
                            $"Shop {shopStatus.ShopId} should not have sync errors after business sync in iteration {iteration}");
                        
                        // Pending uploads should be minimal after successful sync
                        Assert.True(shopStatus.PendingUploads <= 5,
                            $"Shop {shopStatus.ShopId} should have minimal pending uploads after sync in iteration {iteration}. " +
                            $"Got: {shopStatus.PendingUploads}");
                    }
                }
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

                // Verify base total matches sum of line items
                var saleItems = await saleItemRepository.FindAsync(si => si.SaleId == sale.Id);
                var actualSumOfLineItems = saleItems.Sum(si => si.TotalPrice);
                
                var baseTotalDifference = Math.Abs(actualLineTotal - actualSumOfLineItems);
                Assert.True(baseTotalDifference <= tolerance,
                    $"Base total should match sum of line items in iteration {iteration}. " +
                    $"Base Total: {actualLineTotal:C}, Sum of Line Items: {actualSumOfLineItems:C}, " +
                    $"Difference: {baseTotalDifference:C}");

                // Verify all amounts are non-negative
                Assert.True(actualLineTotal >= 0, $"Base total should be non-negative in iteration {iteration}");
                Assert.True(discountAmount >= 0, $"Discount amount should be non-negative in iteration {iteration}");
                Assert.True(taxAmount >= 0, $"Tax amount should be non-negative in iteration {iteration}");
                Assert.True(finalTotal >= 0, $"Final total should be non-negative in iteration {iteration}");

                // Verify discounts don't exceed base total
                Assert.True(discountAmount <= actualLineTotal,
                    $"Discount amount should not exceed base total in iteration {iteration}. " +
                    $"Discount: {discountAmount:C}, Base: {actualLineTotal:C}");

                // Verify calculation is deterministic - same input should give same result
                var secondCalculationResult = await enhancedSalesService.CalculateWithBusinessRulesAsync(sale);
                Assert.Equal(calculationResult.FinalTotal, secondCalculationResult.FinalTotal);
                Assert.Equal(calculationResult.BaseTotal, secondCalculationResult.BaseTotal);
                Assert.Equal(calculationResult.DiscountAmount, secondCalculationResult.DiscountAmount);
                Assert.Equal(calculationResult.TaxAmount, secondCalculationResult.TaxAmount);
            }
            finally
            {
                CleanupTestData();
            }
        }
    }

    /// <summary>
    /// Generates test data for a business including shops, products, sales, and stock
    /// </summary>
    private static BusinessTestData GenerateBusinessData()
    {
        var random = new Random();
        return new BusinessTestData
        {
            BusinessId = Guid.NewGuid(),
            OwnerId = Guid.NewGuid(),
            BusinessType = (BusinessType)random.Next(0, Enum.GetValues<BusinessType>().Length),
            ShopCount = random.Next(1, 4), // 1-3 shops per business
            ProductCount = random.Next(1, 6), // 1-5 products per shop
            SaleCount = random.Next(0, 4) // 0-3 sales per shop
        };
    }

    /// <summary>
    /// Generates random sync test data for inventory synchronization testing
    /// </summary>
    private static SyncTestData GenerateRandomSyncTestData()
    {
        var random = new Random();
        var productCount = random.Next(2, 8); // 2-7 products for testing
        
        return new SyncTestData
        {
            BusinessId = Guid.NewGuid(),
            ShopId = Guid.NewGuid(),
            UserId = Guid.NewGuid(),
            ProductIds = Enumerable.Range(0, productCount).Select(_ => Guid.NewGuid()).ToList(),
            DeviceIds = new List<Guid> { Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid() } // 3 devices
        };
    }

    /// <summary>
    /// Sets up test data for synchronization testing
    /// </summary>
    private async Task SetupSyncTestDataAsync(SyncTestData syncTestData)
    {
        // Create business owner
        var owner = new User
        {
            Id = syncTestData.UserId,
            BusinessId = syncTestData.BusinessId,
            Username = $"owner_{syncTestData.UserId:N}",
            FullName = $"Owner {syncTestData.UserId:N}",
            Email = $"owner_{syncTestData.UserId:N}@test.com",
            PasswordHash = "hash",
            Salt = "salt",
            Role = UserRole.BusinessOwner,
            DeviceId = syncTestData.DeviceIds[0]
        };

        // Create business
        var business = new Business
        {
            Id = syncTestData.BusinessId,
            Name = $"Business {syncTestData.BusinessId:N}",
            Type = BusinessType.GeneralRetail,
            OwnerId = syncTestData.UserId,
            DeviceId = syncTestData.DeviceIds[0]
        };

        // Create shop
        var shop = new Shop
        {
            Id = syncTestData.ShopId,
            BusinessId = syncTestData.BusinessId,
            Name = $"Shop {syncTestData.ShopId:N}",
            DeviceId = syncTestData.DeviceIds[0]
        };

        _context.Users.Add(owner);
        _context.Businesses.Add(business);
        _context.Shops.Add(shop);

        // Create products and initial stock
        for (int i = 0; i < syncTestData.ProductIds.Count; i++)
        {
            var productId = syncTestData.ProductIds[i];
            var product = new Product
            {
                Id = productId,
                ShopId = syncTestData.ShopId,
                Name = $"Product {i + 1}",
                Barcode = $"BC{productId:N}",
                UnitPrice = 10.00m + i,
                DeviceId = syncTestData.DeviceIds[0]
            };

            var stock = new Stock
            {
                Id = Guid.NewGuid(),
                ShopId = syncTestData.ShopId,
                ProductId = productId,
                Quantity = 100 + i * 10, // Initial stock: 100, 110, 120, etc.
                LastUpdatedAt = DateTime.UtcNow.AddMinutes(-60), // 1 hour ago
                DeviceId = syncTestData.DeviceIds[0]
            };

            _context.Products.Add(product);
            _context.Stock.Add(stock);
        }

        await _context.SaveChangesAsync();
    }

    /// <summary>
    /// Generates inventory conflict scenarios for testing
    /// </summary>
    private static List<InventoryConflictScenario> GenerateInventoryConflictScenarios(SyncTestData syncTestData)
    {
        var random = new Random();
        var scenarios = new List<InventoryConflictScenario>();
        
        // Generate 2-4 conflict scenarios per test
        var scenarioCount = random.Next(2, 5);
        
        for (int i = 0; i < scenarioCount; i++)
        {
            var affectedProductCount = random.Next(1, Math.Min(4, syncTestData.ProductIds.Count));
            var affectedProducts = syncTestData.ProductIds.Take(affectedProductCount).ToList();
            
            var scenario = new InventoryConflictScenario
            {
                ScenarioId = i + 1,
                AffectedProducts = affectedProducts,
                LocalChanges = GenerateRandomInventoryChanges(affectedProducts, syncTestData.DeviceIds[1], random),
                ServerChanges = GenerateRandomInventoryChanges(affectedProducts, syncTestData.DeviceIds[2], random)
            };
            
            scenarios.Add(scenario);
        }
        
        return scenarios;
    }

    /// <summary>
    /// Generates random inventory changes for conflict simulation
    /// </summary>
    private static List<InventoryChange> GenerateRandomInventoryChanges(List<Guid> productIds, Guid deviceId, Random random)
    {
        var changes = new List<InventoryChange>();
        
        foreach (var productId in productIds)
        {
            // 70% chance of change per product
            if (random.Next(0, 10) < 7)
            {
                var changeType = (InventoryChangeType)random.Next(0, 3);
                var quantityChange = changeType switch
                {
                    InventoryChangeType.Sale => -random.Next(1, 20), // Reduce stock
                    InventoryChangeType.Purchase => random.Next(10, 100), // Increase stock
                    InventoryChangeType.Adjustment => random.Next(-30, 50), // Can be positive or negative
                    _ => 0
                };
                
                changes.Add(new InventoryChange
                {
                    ProductId = productId,
                    QuantityChange = quantityChange,
                    ChangeType = changeType,
                    Timestamp = DateTime.UtcNow.AddMinutes(-random.Next(1, 30)), // 1-30 minutes ago
                    DeviceId = deviceId,
                    Reason = $"{changeType} from device {deviceId:N}"
                });
            }
        }
        
        return changes;
    }

    /// <summary>
    /// Applies local inventory changes to simulate offline updates
    /// </summary>
    private async Task ApplyLocalInventoryChangesAsync(List<InventoryChange> localChanges)
    {
        foreach (var change in localChanges)
        {
            var stock = await _context.Stock.FirstOrDefaultAsync(s => s.ProductId == change.ProductId);
            if (stock != null)
            {
                stock.Quantity = Math.Max(0, stock.Quantity + change.QuantityChange);
                stock.LastUpdatedAt = change.Timestamp;
                stock.DeviceId = change.DeviceId;
                stock.SyncStatus = SyncStatus.NotSynced; // Mark as needing sync
            }
        }
        
        await _context.SaveChangesAsync();
    }

    /// <summary>
    /// Applies server inventory changes to simulate server-side updates
    /// </summary>
    private async Task ApplyServerInventoryChangesAsync(List<InventoryChange> serverChanges)
    {
        // In a real scenario, these would come from the server
        // For testing, we'll create separate stock records to simulate server state
        foreach (var change in serverChanges)
        {
            var stock = await _context.Stock.FirstOrDefaultAsync(s => s.ProductId == change.ProductId);
            if (stock != null)
            {
                // Create a "server version" by modifying the timestamp and device
                // This simulates what would happen when server data conflicts with local data
                var serverQuantity = Math.Max(0, stock.Quantity + change.QuantityChange);
                
                // Store server state in a way that will create conflicts
                stock.ServerQuantity = serverQuantity;
                stock.ServerLastUpdatedAt = change.Timestamp;
                stock.ServerDeviceId = change.DeviceId;
            }
        }
        
        await _context.SaveChangesAsync();
    }

    /// <summary>
    /// Creates data conflicts for testing conflict resolution
    /// </summary>
    private async Task<List<DataConflict>> CreateInventoryConflictsAsync(InventoryConflictScenario scenario)
    {
        var conflicts = new List<DataConflict>();
        
        foreach (var productId in scenario.AffectedProducts)
        {
            var stock = await _context.Stock.FirstOrDefaultAsync(s => s.ProductId == productId);
            if (stock != null && stock.ServerQuantity.HasValue)
            {
                // Create conflict between local and server data
                var conflict = new DataConflict
                {
                    EntityType = nameof(Stock),
                    EntityId = stock.Id,
                    BusinessId = stock.Shop?.BusinessId ?? Guid.Empty,
                    ShopId = stock.ShopId,
                    LocalData = new { Quantity = stock.Quantity, LastUpdatedAt = stock.LastUpdatedAt, DeviceId = stock.DeviceId },
                    ServerData = new { Quantity = stock.ServerQuantity.Value, LastUpdatedAt = stock.ServerLastUpdatedAt, DeviceId = stock.ServerDeviceId },
                    LocalTimestamp = stock.LastUpdatedAt,
                    ServerTimestamp = stock.ServerLastUpdatedAt ?? DateTime.UtcNow,
                    Type = ConflictType.UpdateConflict,
                    ConflictReason = "Concurrent inventory updates from different devices"
                };
                
                conflicts.Add(conflict);
            }
        }
        
        return conflicts;
    }

    /// <summary>
    /// Sets up test data for a business in the database
    /// </summary>
    private void SetupBusinessData(BusinessTestData data)
    {
        // Create business owner
        var owner = new User
        {
            Id = data.OwnerId,
            BusinessId = data.BusinessId, // This will be updated after business creation
            Username = $"owner_{data.BusinessId:N}",
            FullName = $"Owner {data.BusinessId:N}",
            Email = $"owner_{data.BusinessId:N}@test.com",
            PasswordHash = "hash",
            Salt = "salt",
            Role = UserRole.BusinessOwner,
            DeviceId = Guid.NewGuid()
        };

        // Create business
        var business = new Business
        {
            Id = data.BusinessId,
            Name = $"Business {data.BusinessId:N}",
            Type = data.BusinessType,
            OwnerId = data.OwnerId,
            DeviceId = Guid.NewGuid()
        };

        // Update owner's business reference
        owner.BusinessId = business.Id;

        _context.Users.Add(owner);
        _context.Businesses.Add(business);

        // Create shops for the business
        for (int i = 0; i < data.ShopCount; i++)
        {
            var shopId = Guid.NewGuid();
            var shop = new Shop
            {
                Id = shopId,
                BusinessId = data.BusinessId,
                Name = $"Shop {i + 1} - {data.BusinessId:N}",
                DeviceId = Guid.NewGuid()
            };

            _context.Shops.Add(shop);

            // Create products for the shop
            for (int j = 0; j < data.ProductCount; j++)
            {
                var productId = Guid.NewGuid();
                var product = new Product
                {
                    Id = productId,
                    ShopId = shopId,
                    Name = $"Product {j + 1} - Shop {i + 1} - {data.BusinessId:N}",
                    Barcode = $"BC{data.BusinessId:N}{i}{j}",
                    UnitPrice = 10.00m + j,
                    DeviceId = Guid.NewGuid()
                };

                _context.Products.Add(product);

                // Create stock for the product
                var stock = new Stock
                {
                    Id = Guid.NewGuid(),
                    ShopId = shopId,
                    ProductId = productId,
                    Quantity = 100 + j,
                    DeviceId = Guid.NewGuid()
                };

                _context.Stock.Add(stock);
            }

            // Create sales for the shop
            for (int k = 0; k < data.SaleCount; k++)
            {
                var sale = new Sale
                {
                    Id = Guid.NewGuid(),
                    ShopId = shopId,
                    UserId = data.OwnerId,
                    InvoiceNumber = $"INV{data.BusinessId:N}{i}{k}",
                    TotalAmount = 50.00m + k,
                    PaymentMethod = PaymentMethod.Cash,
                    DeviceId = Guid.NewGuid()
                };

                _context.Sales.Add(sale);
            }
        }

        _context.SaveChanges();
    }

    /// <summary>
    /// Cleans up test data from the database
    /// </summary>
    private void CleanupTestData()
    {
        try
        {
            // Remove all test data
            _context.Stock.RemoveRange(_context.Stock);
            _context.Sales.RemoveRange(_context.Sales);
            _context.Products.RemoveRange(_context.Products);
            _context.Shops.RemoveRange(_context.Shops);
            _context.Businesses.RemoveRange(_context.Businesses);
            _context.Users.RemoveRange(_context.Users);
            _context.SaveChanges();
        }
        catch (Exception)
        {
            // Ignore cleanup errors
        }
    }

    /// <summary>
    /// Generates random business type attributes based on business type
    /// </summary>
    private static BusinessTypeAttributes GenerateRandomBusinessTypeAttributes(BusinessType businessType, Random random)
    {
        var attributes = new BusinessTypeAttributes();

        switch (businessType)
        {
            case BusinessType.Pharmacy:
                // Sometimes generate invalid expiry dates to test validation
                attributes.ExpiryDate = random.Next(0, 2) == 0 
                    ? DateTime.UtcNow.AddDays(random.Next(-30, 365)) // Past or future
                    : DateTime.UtcNow.AddDays(random.Next(1, 365)); // Always future
                
                attributes.Manufacturer = random.Next(0, 3) == 0 ? null : $"Manufacturer{random.Next(1, 100)}";
                attributes.BatchNumber = random.Next(0, 4) == 0 ? null : $"BATCH{random.Next(1000, 9999)}";
                attributes.GenericName = $"Generic{random.Next(1, 50)}";
                attributes.Dosage = $"{random.Next(1, 500)}mg";
                break;

            case BusinessType.Grocery:
                attributes.Weight = random.Next(0, 3) == 0 
                    ? (decimal)(random.NextDouble() * 2 - 0.5) // Sometimes negative to test validation
                    : (decimal)(random.NextDouble() * 10 + 0.1); // Always positive
                
                attributes.Volume = $"{random.Next(100, 2000)}ml";
                attributes.Unit = random.Next(0, 4) == 0 ? null : new[] { "kg", "piece", "liter", "gram" }[random.Next(4)];
                break;

            case BusinessType.SuperShop:
                attributes.Weight = random.Next(0, 2) == 0 ? (decimal)(random.NextDouble() * 10 + 0.1) : null;
                attributes.Volume = random.Next(0, 2) == 0 ? $"{random.Next(100, 2000)}ml" : null;
                attributes.Unit = new[] { "kg", "piece", "liter", "gram", "box" }[random.Next(5)];
                break;

            case BusinessType.GeneralRetail:
            case BusinessType.Custom:
            default:
                // Minimal attributes for general retail
                attributes.Weight = random.Next(0, 3) == 0 ? (decimal)(random.NextDouble() * 5 + 0.1) : null;
                break;
        }

        return attributes;
    }

    /// <summary>
    /// Generates test data for a business with multiple shops
    /// </summary>
    private static BusinessWithShopsTestData GenerateBusinessWithMultipleShops()
    {
        var random = new Random();
        var shopCount = random.Next(2, 5); // 2-4 shops
        
        return new BusinessWithShopsTestData
        {
            BusinessId = Guid.NewGuid(),
            OwnerId = Guid.NewGuid(),
            BusinessType = (BusinessType)random.Next(0, Enum.GetValues<BusinessType>().Length),
            ShopIds = Enumerable.Range(0, shopCount).Select(_ => Guid.NewGuid()).ToList()
        };
    }

    /// <summary>
    /// Sets up test data for a business with multiple shops
    /// </summary>
    private void SetupBusinessWithShops(BusinessWithShopsTestData data)
    {
        // Create business owner
        var owner = new User
        {
            Id = data.OwnerId,
            BusinessId = data.BusinessId,
            Username = $"owner_{data.BusinessId:N}",
            FullName = $"Owner {data.BusinessId:N}",
            Email = $"owner_{data.BusinessId:N}@test.com",
            PasswordHash = "hash",
            Salt = "salt",
            Role = UserRole.BusinessOwner,
            DeviceId = Guid.NewGuid()
        };

        // Create business
        var business = new Business
        {
            Id = data.BusinessId,
            Name = $"Business {data.BusinessId:N}",
            Type = data.BusinessType,
            OwnerId = data.OwnerId,
            DeviceId = Guid.NewGuid()
        };

        _context.Users.Add(owner);
        _context.Businesses.Add(business);

        // Create shops for the business
        for (int i = 0; i < data.ShopIds.Count; i++)
        {
            var shop = new Shop
            {
                Id = data.ShopIds[i],
                BusinessId = data.BusinessId,
                Name = $"Shop {i + 1} - {data.BusinessId:N}",
                Configuration = GenerateRandomShopConfigurationJson(),
                DeviceId = Guid.NewGuid()
            };

            _context.Shops.Add(shop);
        }

        _context.SaveChanges();
    }

    /// <summary>
    /// Generates random shop configuration
    /// </summary>
    private static ShopConfiguration GenerateRandomShopConfiguration(Random random)
    {
        return new ShopConfiguration
        {
            Currency = new[] { "USD", "EUR", "GBP", "CAD" }[random.Next(4)],
            TaxRate = (decimal)(random.NextDouble() * 0.3), // 0-30%
            PricingRules = new PricingRules
            {
                AllowPriceOverride = random.Next(0, 2) == 1,
                MaxDiscountPercentage = (decimal)(random.NextDouble() * 0.5), // 0-50%
                EnableDynamicPricing = random.Next(0, 2) == 1
            },
            InventorySettings = new InventorySettings
            {
                EnableLowStockAlerts = random.Next(0, 2) == 1,
                LowStockThreshold = random.Next(1, 50),
                EnableAutoReorder = random.Next(0, 2) == 1,
                ExpiryAlertDays = random.Next(1, 90)
            }
        };
    }

    /// <summary>
    /// Generates random shop configuration as JSON string
    /// </summary>
    private static string GenerateRandomShopConfigurationJson()
    {
        var random = new Random();
        var config = GenerateRandomShopConfiguration(random);
        return System.Text.Json.JsonSerializer.Serialize(config);
    }

    /// <summary>
    /// Generates random user data for testing
    /// </summary>
    private static UserTestData GenerateRandomUserData()
    {
        var random = new Random();
        var roles = Enum.GetValues<UserRole>();
        var role = roles[random.Next(roles.Length)];
        
        return new UserTestData
        {
            UserId = Guid.NewGuid(),
            BusinessId = Guid.NewGuid(),
            ShopId = random.Next(0, 3) == 0 ? null : Guid.NewGuid(), // 33% chance of no shop assignment
            Role = role,
            Username = $"user_{Guid.NewGuid():N}",
            Email = $"user_{Guid.NewGuid():N}@test.com"
        };
    }

    /// <summary>
    /// Creates a test user in the database
    /// </summary>
    private async Task<User> CreateTestUser(UserTestData userData)
    {
        var userService = _serviceProvider.GetRequiredService<IUserService>();
        
        // Create business first
        var business = new Business
        {
            Id = userData.BusinessId,
            Name = $"Business {userData.BusinessId:N}",
            Type = BusinessType.GeneralRetail,
            OwnerId = userData.UserId,
            DeviceId = Guid.NewGuid()
        };
        _context.Businesses.Add(business);

        // Create shop if specified
        if (userData.ShopId.HasValue)
        {
            var shop = new Shop
            {
                Id = userData.ShopId.Value,
                BusinessId = userData.BusinessId,
                Name = $"Shop {userData.ShopId:N}",
                DeviceId = Guid.NewGuid()
            };
            _context.Shops.Add(shop);
        }

        await _context.SaveChangesAsync();

        // Create user
        var user = await userService.CreateUserAsync(
            userData.Username, 
            $"Test User {userData.UserId:N}", 
            userData.Email, 
            "Password123!", 
            userData.Role);

        // Update user with business and shop assignments
        user.BusinessId = userData.BusinessId;
        user.ShopId = userData.ShopId;
        
        _context.Users.Update(user);
        await _context.SaveChangesAsync();

        return user;
    }

    /// <summary>
    /// Generates test permissions for validation
    /// </summary>
    private static List<TestPermission> GenerateTestPermissions()
    {
        var permissions = new List<TestPermission>();
        var actions = new[] { "Login", "CreateSale", "RefundSale", "AccessReports", "UpdateInventory", "ChangeUserRole" };
        
        foreach (var action in actions)
        {
            // Test with no shop context
            permissions.Add(new TestPermission { Action = action, ShopId = null });
            
            // Test with specific shop context
            permissions.Add(new TestPermission { Action = action, ShopId = Guid.NewGuid() });
        }

        return permissions;
    }

    /// <summary>
    /// Determines if a user should have access based on role and context
    /// </summary>
    private static bool ShouldUserHaveAccess(UserRole role, TestPermission permission, Guid businessId, Guid? userShopId)
    {
        // Parse the action to AuditAction enum
        if (!Enum.TryParse<AuditAction>(permission.Action, out var auditAction))
        {
            return false;
        }

        // Check basic role permissions first
        var hasRolePermission = role switch
        {
            UserRole.Cashier => auditAction is AuditAction.Login or AuditAction.Logout or AuditAction.CreateSale,
            UserRole.InventoryStaff => auditAction is AuditAction.Login or AuditAction.Logout or AuditAction.CreateProduct or AuditAction.UpdateProduct or AuditAction.UpdateInventory,
            UserRole.ShopManager => auditAction is AuditAction.Login or AuditAction.Logout or AuditAction.CreateSale or AuditAction.RefundSale or AuditAction.CreateProduct or AuditAction.UpdateProduct or AuditAction.DeleteProduct or AuditAction.UpdateInventory or AuditAction.AccessReports or AuditAction.DataExport or AuditAction.DataImport,
            UserRole.BusinessOwner => true, // Business owners have all permissions
            UserRole.Administrator => true, // Administrators have all permissions
            UserRole.Supervisor => auditAction is AuditAction.Login or AuditAction.Logout or AuditAction.CreateSale or AuditAction.RefundSale or AuditAction.AccessReports or AuditAction.UpdateInventory,
            UserRole.Manager => auditAction is AuditAction.Login or AuditAction.Logout or AuditAction.CreateSale or AuditAction.RefundSale or AuditAction.CreateProduct or AuditAction.UpdateProduct or AuditAction.DeleteProduct or AuditAction.UpdateInventory or AuditAction.AccessReports or AuditAction.DataExport or AuditAction.DataImport,
            _ => false
        };

        if (!hasRolePermission)
        {
            return false;
        }

        // Check shop-level access if shop context is provided
        if (permission.ShopId.HasValue)
        {
            // Business owners can access all shops
            if (role == UserRole.BusinessOwner)
            {
                return true;
            }

            // Other roles need specific shop assignment or no shop restriction
            return userShopId == null || userShopId == permission.ShopId;
        }

        return true;
    }

    /// <summary>
    /// Generates a random authentication token for testing
    /// </summary>
    private static string GenerateRandomToken()
    {
        var random = new Random();
        var bytes = new byte[32];
        random.NextBytes(bytes);
        return Convert.ToBase64String(bytes);
    }

    /// <summary>
    /// Generates random sale test data
    /// </summary>
    private static SaleTestData GenerateRandomSaleTestData()
    {
        var random = new Random();
        var itemCount = random.Next(1, 6); // 1-5 items per sale
        
        var saleItems = new List<SaleItemTestData>();
        for (int i = 0; i < itemCount; i++)
        {
            var isWeightBased = random.Next(0, 4) == 0; // 25% chance of weight-based
            saleItems.Add(new SaleItemTestData
            {
                ProductId = Guid.NewGuid(),
                Quantity = isWeightBased ? 1 : random.Next(1, 10),
                UnitPrice = (decimal)(random.NextDouble() * 100 + 1), // $1-$100
                Weight = isWeightBased ? Math.Round((decimal)(random.NextDouble() * 4.9 + 0.001), 3) : null, // 0.001-4.901 kg with 3 decimal places
                IsWeightBased = isWeightBased,
                BatchNumber = random.Next(0, 3) == 0 ? $"BATCH{random.Next(1000, 9999)}" : null
            });
        }

        return new SaleTestData
        {
            BusinessId = Guid.NewGuid(),
            ShopId = Guid.NewGuid(),
            UserId = Guid.NewGuid(),
            BusinessType = (BusinessType)random.Next(0, Enum.GetValues<BusinessType>().Length),
            SaleItems = saleItems
        };
    }

    /// <summary>
    /// Sets up test data for a sale scenario
    /// </summary>
    private async Task SetupSaleTestDataAsync(SaleTestData saleTestData)
    {
        // Create business owner
        var owner = new User
        {
            Id = saleTestData.UserId,
            BusinessId = saleTestData.BusinessId,
            Username = $"user_{saleTestData.UserId:N}",
            FullName = $"User {saleTestData.UserId:N}",
            Email = $"user_{saleTestData.UserId:N}@test.com",
            PasswordHash = "hash",
            Salt = "salt",
            Role = UserRole.Cashier,
            DeviceId = Guid.NewGuid()
        };

        // Create business
        var business = new Business
        {
            Id = saleTestData.BusinessId,
            Name = $"Business {saleTestData.BusinessId:N}",
            Type = saleTestData.BusinessType,
            OwnerId = saleTestData.UserId,
            DeviceId = Guid.NewGuid()
        };

        // Create shop
        var shop = new Shop
        {
            Id = saleTestData.ShopId,
            BusinessId = saleTestData.BusinessId,
            Name = $"Shop {saleTestData.ShopId:N}",
            Configuration = GenerateRandomShopConfigurationJson(),
            DeviceId = Guid.NewGuid()
        };

        _context.Users.Add(owner);
        _context.Businesses.Add(business);
        _context.Shops.Add(shop);

        // Create products for the sale items
        foreach (var itemData in saleTestData.SaleItems)
        {
            var product = new Product
            {
                Id = itemData.ProductId,
                ShopId = saleTestData.ShopId,
                Name = $"Product {itemData.ProductId:N}",
                Barcode = $"BC{itemData.ProductId:N}",
                UnitPrice = itemData.UnitPrice,
                IsWeightBased = itemData.IsWeightBased,
                RatePerKilogram = itemData.IsWeightBased ? itemData.UnitPrice : null,
                WeightPrecision = itemData.IsWeightBased ? 3 : 0,
                DeviceId = Guid.NewGuid()
            };

            _context.Products.Add(product);

            // Create stock for the product
            var stock = new Stock
            {
                Id = Guid.NewGuid(),
                ShopId = saleTestData.ShopId,
                ProductId = itemData.ProductId,
                Quantity = itemData.IsWeightBased ? 1000 : itemData.Quantity * 2, // Ensure sufficient stock
                DeviceId = Guid.NewGuid()
            };

            _context.Stock.Add(stock);
        }

        await _context.SaveChangesAsync();
    }

    public void Dispose()
    {
        _context?.Dispose();
        _serviceProvider?.Dispose();
    }

    /// <summary>
    /// Test data structure for sale testing
    /// </summary>
    private class SaleTestData
    {
        public Guid BusinessId { get; set; }
        public Guid ShopId { get; set; }
        public Guid UserId { get; set; }
        public BusinessType BusinessType { get; set; }
        public List<SaleItemTestData> SaleItems { get; set; } = new();
    }

    /// <summary>
    /// Test data structure for sale item testing
    /// </summary>
    private class SaleItemTestData
    {
        public Guid ProductId { get; set; }
        public int Quantity { get; set; }
        public decimal UnitPrice { get; set; }
        public decimal? Weight { get; set; }
        public bool IsWeightBased { get; set; }
        public string? BatchNumber { get; set; }
    }

    /// <summary>
    /// Test data structure for a business with multiple shops
    /// </summary>
    private class BusinessWithShopsTestData
    {
        public Guid BusinessId { get; set; }
        public Guid OwnerId { get; set; }
        public BusinessType BusinessType { get; set; }
        public List<Guid> ShopIds { get; set; } = new();
    }

    /// <summary>
    /// Test data structure for a business
    /// </summary>
    private class BusinessTestData
    {
        public Guid BusinessId { get; set; }
        public Guid OwnerId { get; set; }
        public BusinessType BusinessType { get; set; }
        public int ShopCount { get; set; }
        public int ProductCount { get; set; }
        public int SaleCount { get; set; }
    }

    /// <summary>
    /// Test data structure for user testing
    /// </summary>
    private class UserTestData
    {
        public Guid UserId { get; set; }
        public Guid BusinessId { get; set; }
        public Guid? ShopId { get; set; }
        public UserRole Role { get; set; }
        public string Username { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;

        public bool CanAccessShop(Guid shopId)
        {
            return Role == UserRole.BusinessOwner || ShopId == null || ShopId == shopId;
        }
    }

    /// <summary>
    /// Test permission structure
    /// </summary>
    private class TestPermission
    {
        public string Action { get; set; } = string.Empty;
        public Guid? ShopId { get; set; }
    }

    /// <summary>
    /// Test data structure for synchronization testing
    /// </summary>
    private class SyncTestData
    {
        public Guid BusinessId { get; set; }
        public Guid ShopId { get; set; }
        public Guid UserId { get; set; }
        public List<Guid> ProductIds { get; set; } = new();
        public List<Guid> DeviceIds { get; set; } = new();
    }

    /// <summary>
    /// Inventory conflict scenario for testing
    /// </summary>
    private class InventoryConflictScenario
    {
        public int ScenarioId { get; set; }
        public List<Guid> AffectedProducts { get; set; } = new();
        public List<InventoryChange> LocalChanges { get; set; } = new();
        public List<InventoryChange> ServerChanges { get; set; } = new();
    }

    /// <summary>
    /// Inventory change for conflict simulation
    /// </summary>
    private class InventoryChange
    {
        public Guid ProductId { get; set; }
        public int QuantityChange { get; set; }
        public InventoryChangeType ChangeType { get; set; }
        public DateTime Timestamp { get; set; }
        public Guid DeviceId { get; set; }
        public string Reason { get; set; } = string.Empty;
    }

    /// <summary>
    /// Types of inventory changes
    /// </summary>
    private enum InventoryChangeType
    {
        Sale,
        Purchase,
        Adjustment
    }
}